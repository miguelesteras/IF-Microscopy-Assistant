%% Phase 4.1. Transform cell mask into Fourier descriptors
%   ======================================================================
%   Code by Miguel Esteras-Bejar, 07/2017
%   This code is part of the project:
%   'Tracking of temporally occluded or overlapping structures in live cell
%   microscopy'
%   This codes aims to:
%   1. Extract sequences of frames (f1, f2, ... , fx), from which
%   input sequence = (f1, f2, ... , fx-1), and target sequence = fx
%   2. Transform cell mask into Fourier descriptors.
%   Fourier descriptors as first described by Kuhl and Giardina in 
%   "Elliptic Fourier features of a closed contour" 
%   Computer Graphics and Image Processing 18:236-258 1982
%   
%   This code is a modification of: 
%   http://geekstack.net/index.php?page=fourier_descriptor
%   Copyright © Tobias Pohlen 2017
%   A basic implementation of the descriptor presented in:
%   O. D. Trier, A. K. Jain, T. Taxt, Feature Extraction Methods for 
%   Character Recognition - A Survey, Pattern Recognition, Vol. 29, No. 4, 
%   pp. 641 - 662 (1996).
%   ======================================================================

% seqLength = Number of frames in learning sequence (x input + 1 target).
% C determines the number of coefficients (and the description vector
% size). P determines the number of sampling points used for the fourier
% transform (in percentage of total number of points). The transformation
% is set not to be rotation invariant.
seqLength = 8;              
C = 20;                 
P = 0.12;          
rotationInva = false;

files = dir('*_metadata.mat');      
num_files = length(files);
for i = 1:num_files
    load(files(i).name,'metadata');                                  
    load(strcat(metadata.name,'_rotationUp.mat'),'rotationUp');
    load(strcat(metadata.name,'_cellCoordinates.mat'),'cellCoordinates'); 

    % detect sequence of length equal or greater than seqLength
    noFrames = sum(double(~cellfun(@isempty,cellCoordinates)),2);
    idx = find(noFrames >= seqLength);
    fourierDescriptor = cell(100,seqLength); 
    count = 1;
    
    for j = 1:size(idx,1)
        idx2 = find(~cellfun(@isempty,cellCoordinates(idx(j),:)));
        for k = 1:size(idx2,2) - (seqLength-1)
            rotation = rotationUp{idx(j),idx2(k)};
            
            for m = 1:seqLength
                canvas = false((metadata.maxRadious*2)+1, (metadata.maxRadious*2)+1);
                selection = cellCoordinates{idx(j),idx2(k+m-1)};
                selection(:,1) = wrapTo2Pi(selection(:,1) + rotation);          
                [x,y] = pol2cart(selection(:,1),selection(:,2));
                colSub = round(x)+metadata.maxRadious+1; 
                rowSub = round(y)+metadata.maxRadious+1;
                cellIdx = sub2ind(size(canvas), rowSub, colSub);
                canvas(cellIdx) = true;
                canvas = imfill(canvas,'holes');
                [a,b,c,d,~] = ellipticFourierDescriptor(canvas, C, P, rotationInva);
                fourierDescriptor{count,m} = [a;b;c;d];
            end   
        count = count +1;
        end
    end
    save(strcat(metadata.name,'_fourierDescriptor.mat'),'fourierDescriptor');
    %clearvars -except files num_files i
end


%% Image reconstruction from Fourier descriptor 
T = 300; % number of sampling points for reconstruction.
xt = ellipticFourierFunction(a,b,T);
yt = ellipticFourierFunction(c,d,T);
for t = 1:T
    pl(t) = xt(t) + i*yt(t);
end
% plot reconstructed image with center [100,100] and rescale by scaleF.
% scaleF = 50;
x2 = round(real(pl))';
y2 = round(imag(pl))';
scaleF = range(x)/range(x2);
ind2 = sub2ind([200,200], y2+100, x2+100);
canvas2 = false(200,200);
canvas2(ind2) = true;
figure
imshowpair(canvas,canvas2,'montage');
%%
selec = fourierDescriptor
a = fourierDescriptor
b = 
c = 
d = 


% Receive the fourier functions
xt = ellipticFourierFunction(a,b,T);
yt = ellipticFourierFunction(c,d,T);

k = 1;
for it = 0:0.2:T
    pl(k) = xt(it) + i*yt(it);
    k = k + 1;
end